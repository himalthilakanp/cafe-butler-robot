#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
from collections import deque
import math


# ---------------- CONFIG ---------------- #

TABLE_DWELL_TIMEOUT = 8.0
KITCHEN_TIMEOUT = 5.0

HOME = (5.5, 5.5)
KITCHEN = (9.0, 9.0)

TABLES = {
    "table1": (2.0, 8.0),
    "table2": (8.0, 2.0),
    "table3": (2.0, 2.0),
}


# ---------------- NODE ---------------- #

class ButlerTaskManager(Node):

    def __init__(self):
        super().__init__("butler_task_manager")

        # Publishers
        self.cmd_pub = self.create_publisher(Twist, "/turtle1/cmd_vel", 10)
        self.status_pub = self.create_publisher(String, "/amr_status", 10)

        # Subscribers
        self.create_subscription(String, "/orders", self.order_callback, 10)
        self.create_subscription(String, "/cancel_order", self.cancel_callback, 10)
        self.create_subscription(String, "/kitchen_confirm", self.kitchen_confirm_callback, 10)
        self.create_subscription(String, "/customer_confirm", self.customer_confirm_callback, 10)
        self.create_subscription(Pose, "/turtle1/pose", self.pose_callback, 10)

        # FSM
        self.state = "IDLE"
        self.order_queue = deque()
        self.current_table = None
        self.current_pose = None

        self.kitchen_confirmed = False
        self.customer_confirmed = False
        self.initial_collection_done = False

        # Timers
        self.create_timer(0.05, self.control_loop)
        self.create_timer(2.0, self.publish_status)

        self.get_logger().info("üöÄ Butler Task Manager Started")


    # ---------------- CALLBACKS ---------------- #

    def pose_callback(self, msg):
        self.current_pose = msg


    def order_callback(self, msg):
        tables = [t.strip().lower() for t in msg.data.split(",") if t.strip()]

        for table in tables:
            if table in TABLES:
                self.order_queue.append(table)
                self.get_logger().info(f"üìù Added {table}")
            else:
                self.get_logger().warn(f"Invalid table: {table}")

        if self.state == "IDLE" and self.order_queue:
            self.state = "GOING_TO_KITCHEN"
            self.initial_collection_done = False
            self.get_logger().info("‚û° GOING_TO_KITCHEN")


    def cancel_callback(self, msg):
        table = msg.data.strip().lower()
        self.get_logger().info(f"‚ùå Cancel request for {table}")

        # Remove cancelled table from queue
        self.order_queue = deque(t for t in self.order_queue if t != table)

        # If currently serving that table
        if self.current_table == table:
            self.get_logger().info("‚ö† Current table cancelled")
            self.current_table = None
            self.state = "GOING_TO_KITCHEN"


    def kitchen_confirm_callback(self, msg):
        if msg.data.lower() == "ready":
            self.kitchen_confirmed = True
            self.get_logger().info("‚úÖ Kitchen Confirmed")


    def customer_confirm_callback(self, msg):
        if msg.data.lower() == "received":
            self.customer_confirmed = True
            self.get_logger().info("‚úÖ Customer Confirmed Delivery")


    def publish_status(self):
        msg = String()
        msg.data = f"{self.state} | Pending: {len(self.order_queue)}"
        self.status_pub.publish(msg)


    # ---------------- MOVEMENT ---------------- #

    def move_to(self, target):

        if self.current_pose is None:
            return False

        dx = target[0] - self.current_pose.x
        dy = target[1] - self.current_pose.y
        distance = math.sqrt(dx*dx + dy*dy)

        cmd = Twist()

        if distance > 0.2:

            goal_theta = math.atan2(dy, dx)
            diff = goal_theta - self.current_pose.theta

            if diff > math.pi:
                diff -= 2 * math.pi
            elif diff < -math.pi:
                diff += 2 * math.pi

            cmd.linear.x = min(1.0, distance)
            cmd.angular.z = 6.0 * diff
        else:
            cmd.linear.x = 0.0
            cmd.angular.z = 0.0
            self.cmd_pub.publish(cmd)
            return True

        self.cmd_pub.publish(cmd)
        return False


    # ---------------- FSM ---------------- #

    def control_loop(self):

        if self.current_pose is None:
            return

        now = self.get_clock().now()

        # ---- GOING TO KITCHEN ---- #
        if self.state == "GOING_TO_KITCHEN":

            if self.move_to(KITCHEN):
                self.state = "AT_KITCHEN"
                self.kitchen_timer = now
                self.kitchen_confirmed = False
                self.get_logger().info("‚û° AT_KITCHEN (Waiting confirmation)")


        # ---- AT TABLE ---- #
elif self.state == "AT_TABLE":

    elapsed = (now - self.table_timer).nanoseconds / 1e9

    # ----- If customer confirms -----
    if self.customer_confirmed:

        self.customer_confirmed = False

        if self.order_queue:
            self.current_table = self.order_queue.popleft()
            self.state = "GOING_TO_TABLE"
            self.get_logger().info(f"‚û° GOING_TO_TABLE ({self.current_table})")
        else:
            self.current_table = None
            self.state = "GOING_TO_KITCHEN"
            self.get_logger().info("‚Ü© Final table done ‚Üí Kitchen before Home")

    # ----- If no confirmation (timeout) -----
    elif elapsed > 8.0:

        self.get_logger().warn("Customer confirmation timeout")

        if self.order_queue:
            # Skip table and go to next
            self.current_table = self.order_queue.popleft()
            self.state = "GOING_TO_TABLE"
            self.get_logger().info(f"Skipping ‚Üí GOING_TO_TABLE ({self.current_table})")
        else:
            # Single order OR last table
            self.current_table = None
            self.state = "GOING_TO_KITCHEN"
            self.get_logger().info("Timeout on last table ‚Üí Kitchen before Home")


        # ---- GOING TO TABLE ---- #
        elif self.state == "GOING_TO_TABLE":

            target = TABLES[self.current_table]

            if self.move_to(target):
                self.state = "AT_TABLE"
                self.table_timer = now
                self.customer_confirmed = False
                self.get_logger().info(f"üçΩ AT_TABLE ({self.current_table})")


        # ---- AT TABLE ---- #
        elif self.state == "AT_TABLE":

            elapsed = (now - self.table_timer).nanoseconds / 1e9

            # If customer confirms
            if self.customer_confirmed:

                if self.order_queue:
                    self.current_table = self.order_queue.popleft()
                    self.state = "GOING_TO_TABLE"
                    self.get_logger().info(f"‚û° GOING_TO_TABLE ({self.current_table})")
                else:
                    self.current_table = None
                    self.state = "GOING_TO_KITCHEN"
                    self.get_logger().info("‚Ü© Final table done ‚Üí Kitchen before Home")

            # If timeout
            elif elapsed > TABLE_DWELL_TIMEOUT:

                self.get_logger().warn("‚è≥ Customer confirmation timeout")

                if self.order_queue:
                    self.current_table = self.order_queue.popleft()
                    self.state = "GOING_TO_TABLE"
                    self.get_logger().info(f"Skipping ‚Üí GOING_TO_TABLE ({self.current_table})")
                else:
                    self.current_table = None
                    self.state = "GOING_TO_KITCHEN"
                    self.get_logger().info("Timeout on last table ‚Üí Kitchen before Home")


        # ---- GOING HOME ---- #
        elif self.state == "GOING_HOME":

            if self.move_to(HOME):
                self.state = "IDLE"
                self.initial_collection_done = False
                self.get_logger().info("üè† IDLE")


# ---------------- MAIN ---------------- #

def main():
    rclpy.init()
    node = ButlerTaskManager()
    rclpy.spin(node)
    rclpy.shutdown()


if __name__ == "__main__":
    main()
